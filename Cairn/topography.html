<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cairn RPG Map Generator - Topography</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        h1 {
            text-align: center;
            color: #333;
        }
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        .map-container {
            position: relative;
            border: 1px solid #333;
            background-color: white;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        button {
            padding: 10px 15px;
            background-color: #4a4a4a;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #333;
        }
    </style>
</head>
<body>
    <h1>Cairn RPG Map Generator - Topography</h1>
    
    <div class="container">
        <div class="controls">
            <button id="generateBtn">Generate Terrain</button>
            <button id="clearBtn">Clear Map</button>
        </div>
        
        <div class="map-container">
            <canvas id="mapCanvas" width="800" height="600"></canvas>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('mapCanvas');
            const ctx = canvas.getContext('2d');
            const generateBtn = document.getElementById('generateBtn');
            const clearBtn = document.getElementById('clearBtn');
            
            // Map data structure
            let mapData = {
                width: canvas.width,
                height: canvas.height,
                dice: []
            };
            
            // Clear the map
            function clearMap() {
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                mapData.dice = [];
            }
            
            // Roll a die
            function rollDie() {
                return Math.floor(Math.random() * 6) + 1;
            }
            
            // Generate random dice positions on the map
            function generateDicePositions(numDice) {
                const positions = [];
                const minDistance = 120; // Minimum distance between dice
                const margin = 80;       // Margin from the edges
                
                for (let i = 0; i < numDice; i++) {
                    let x, y, tooClose;
                    let attempts = 0;
                    
                    // Try to find a position that's not too close to existing dice
                    do {
                        tooClose = false;
                        x = margin + Math.random() * (canvas.width - 2 * margin);
                        y = margin + Math.random() * (canvas.height - 2 * margin);
                        
                        for (const pos of positions) {
                            const distance = Math.sqrt(Math.pow(x - pos.x, 2) + Math.pow(y - pos.y, 2));
                            if (distance < minDistance) {
                                tooClose = true;
                                break;
                            }
                        }
                        
                        attempts++;
                        // If we can't find a good position after many attempts, reduce our constraints
                        if (attempts > 50) {
                            minDistance *= 0.9;
                            attempts = 0;
                        }
                    } while (tooClose);
                    
                    positions.push({ x, y });
                }
                
                return positions;
            }
            
            // Draw a die on the canvas
            function drawDie(x, y, value) {
                // Draw die square
                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                
                // Apply small random rotation for visual interest
                ctx.save();
                ctx.translate(x, y);
                const rotation = (Math.random() - 0.5) * 0.2;
                ctx.rotate(rotation);
                
                // Draw die
                const dieSize = 40;
                ctx.fillRect(-dieSize/2, -dieSize/2, dieSize, dieSize);
                ctx.strokeRect(-dieSize/2, -dieSize/2, dieSize, dieSize);
                
                // Draw die value
                ctx.fillStyle = 'black';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(value, 0, 0);
                
                ctx.restore();
            }
            
            // Generate curved boundaries between regions
            function drawRegionBoundaries(dicePositions) {
                // Create a simplified version of a Voronoi diagram
                const resolution = 5; // Check every 5 pixels
                const boundaryThreshold = 8; // Maximum difference in distance to be considered a boundary
                
                // Create a grid to track boundary points
                const boundaryPoints = [];
                const cellSize = 8; // Size of grid cells
                const gridCols = Math.ceil(canvas.width / cellSize);
                const gridRows = Math.ceil(canvas.height / cellSize);
                const grid = Array(gridRows).fill().map(() => Array(gridCols).fill(null));
                
                // Identify boundary points
                for (let x = 0; x < canvas.width; x += resolution) {
                    for (let y = 0; y < canvas.height; y += resolution) {
                        // Find the two closest dice to this point
                        let closest = -1;
                        let secondClosest = -1;
                        let minDist = Infinity;
                        let secondMinDist = Infinity;
                        
                        for (let i = 0; i < dicePositions.length; i++) {
                            const pos = dicePositions[i];
                            const dist = Math.sqrt(Math.pow(x - pos.x, 2) + Math.pow(y - pos.y, 2));
                            
                            if (dist < minDist) {
                                secondMinDist = minDist;
                                secondClosest = closest;
                                minDist = dist;
                                closest = i;
                            } else if (dist < secondMinDist) {
                                secondMinDist = dist;
                                secondClosest = i;
                            }
                        }
                        
                        // If we're almost equidistant to two dice, we're on a boundary
                        if (closest !== -1 && secondClosest !== -1) {
                            const diff = secondMinDist - minDist;
                            if (diff < boundaryThreshold) {
                                // Small random variation for natural look
                                const noisedX = x + (Math.random() - 0.5) * 3;
                                const noisedY = y + (Math.random() - 0.5) * 3;
                                
                                // Add to boundary points
                                boundaryPoints.push({
                                    x: noisedX,
                                    y: noisedY,
                                    region1: closest,
                                    region2: secondClosest
                                });
                                
                                // Store in grid for faster access
                                const gridX = Math.floor(noisedX / cellSize);
                                const gridY = Math.floor(noisedY / cellSize);
                                if (gridX >= 0 && gridX < gridCols && gridY >= 0 && gridY < gridRows) {
                                    if (!grid[gridY][gridX]) {
                                        grid[gridY][gridX] = [];
                                    }
                                    grid[gridY][gridX].push(boundaryPoints.length - 1);
                                }
                            }
                        }
                    }
                }
                
                // Group boundary points into contiguous lines
                const lines = [];
                const used = new Set();
                
                // Function to find nearby points
                function getNearbyPoints(point, radius) {
                    const nearby = [];
                    const centerX = Math.floor(point.x / cellSize);
                    const centerY = Math.floor(point.y / cellSize);
                    const searchRadius = Math.ceil(radius / cellSize) + 1;
                    
                    // Search the grid cells around this point
                    for (let dy = -searchRadius; dy <= searchRadius; dy++) {
                        for (let dx = -searchRadius; dx <= searchRadius; dx++) {
                            const gridX = centerX + dx;
                            const gridY = centerY + dy;
                            
                            if (gridX >= 0 && gridX < gridCols && gridY >= 0 && gridY < gridRows && grid[gridY][gridX]) {
                                for (const idx of grid[gridY][gridX]) {
                                    if (!used.has(idx)) {
                                        const otherPoint = boundaryPoints[idx];
                                        const dist = Math.sqrt(Math.pow(point.x - otherPoint.x, 2) + Math.pow(point.y - otherPoint.y, 2));
                                        if (dist <= radius) {
                                            nearby.push(idx);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                    return nearby;
                }
                
                // Function to trace a line from a starting point
                function traceLine(startIndex) {
                    const line = [boundaryPoints[startIndex]];
                    used.add(startIndex);
                    
                    // Trace in both directions
                    let currentIndex = startIndex;
                    let keepGoing = true;
                    
                    // Forward direction
                    while (keepGoing) {
                        const current = boundaryPoints[currentIndex];
                        const nearby = getNearbyPoints(current, 15);
                        
                        if (nearby.length > 0) {
                            // Find the point that forms the most natural continuation
                            let bestIdx = nearby[0];
                            let bestScore = Infinity;
                            
                            if (line.length >= 2) {
                                // Try to maintain direction
                                const prev = line[line.length - 2];
                                const currentDir = {
                                    x: current.x - prev.x,
                                    y: current.y - prev.y
                                };
                                
                                for (const idx of nearby) {
                                    const next = boundaryPoints[idx];
                                    const nextDir = {
                                        x: next.x - current.x,
                                        y: next.y - current.y
                                    };
                                    
                                    // Dot product to measure alignment
                                    const dot = currentDir.x * nextDir.x + currentDir.y * nextDir.y;
                                    const score = 1 - dot / (Math.sqrt(currentDir.x * currentDir.x + currentDir.y * currentDir.y) * 
                                                            Math.sqrt(nextDir.x * nextDir.x + nextDir.y * nextDir.y));
                                    
                                    if (score < bestScore) {
                                        bestScore = score;
                                        bestIdx = idx;
                                    }
                                }
                            }
                            
                            currentIndex = bestIdx;
                            line.push(boundaryPoints[currentIndex]);
                            used.add(currentIndex);
                        } else {
                            keepGoing = false;
                        }
                    }
                    
                    return line;
                }
                
                // Create lines from boundary points
                for (let i = 0; i < boundaryPoints.length; i++) {
                    if (!used.has(i)) {
                        const line = traceLine(i);
                        if (line.length > 5) { // Skip very short lines
                            lines.push(line);
                        }
                    }
                }
                
                // Draw the boundary lines
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 1.5;
                
                for (const line of lines) {
                    if (line.length < 2) continue;
                    
                    ctx.beginPath();
                    ctx.moveTo(line[0].x, line[0].y);
                    
                    // Draw as a smooth curve using quadratic curves for short segments
                    for (let i = 1; i < line.length; i++) {
                        // For smoother curves, use control points
                        if (i < line.length - 1) {
                            // Calculate control point (midpoint)
                            const cp = {
                                x: (line[i].x + line[i+1].x) / 2,
                                y: (line[i].y + line[i+1].y) / 2
                            };
                            ctx.quadraticCurveTo(line[i].x, line[i].y, cp.x, cp.y);
                        } else {
                            // For the last point
                            ctx.lineTo(line[i].x, line[i].y);
                        }
                    }
                    
                    ctx.stroke();
                }
                
                // Connect lines to the edges of the map with subtle curves
                // This is a simplified approach to ensure all regions are closed
                const edgeConnections = 15; // Number of edge connections to create
                
                ctx.beginPath();
                
                // Create connections to map edges
                for (let i = 0; i < edgeConnections; i++) {
                    // Choose a random position on the edge
                    const side = Math.floor(Math.random() * 4);
                    let startX, startY;
                    
                    // Pick a random point on one of the four sides
                    switch (side) {
                        case 0: // Top
                            startX = Math.random() * canvas.width;
                            startY = 0;
                            break;
                        case 1: // Right
                            startX = canvas.width;
                            startY = Math.random() * canvas.height;
                            break;
                        case 2: // Bottom
                            startX = Math.random() * canvas.width;
                            startY = canvas.height;
                            break;
                        case 3: // Left
                            startX = 0;
                            startY = Math.random() * canvas.height;
                            break;
                    }
                    
                    // Find the closest die
                    let closestDie = null;
                    let minDist = Infinity;
                    
                    for (const pos of dicePositions) {
                        const dist = Math.sqrt(Math.pow(startX - pos.x, 2) + Math.pow(startY - pos.y, 2));
                        if (dist < minDist) {
                            minDist = dist;
                            closestDie = pos;
                        }
                    }
                    
                    if (closestDie) {
                        // Draw a gentle curve from the edge to near the die
                        ctx.moveTo(startX, startY);
                        
                        // Find a point near the die but not right on it
                        const angle = Math.atan2(closestDie.y - startY, closestDie.x - startX);
                        const distance = Math.sqrt(Math.pow(closestDie.x - startX, 2) + Math.pow(closestDie.y - startY, 2));
                        const offsetDistance = distance * 0.3; // Don't go all the way to the die
                        
                        const endX = startX + Math.cos(angle) * (distance - offsetDistance);
                        const endY = startY + Math.sin(angle) * (distance - offsetDistance);
                        
                        // Create a control point for the curve
                        const midX = (startX + endX) / 2;
                        const midY = (startY + endY) / 2;
                        
                        // Add some randomness to the control point
                        const ctrlX = midX + (Math.random() - 0.5) * (distance * 0.3);
                        const ctrlY = midY + (Math.random() - 0.5) * (distance * 0.3);
                        
                        ctx.quadraticCurveTo(ctrlX, ctrlY, endX, endY);
                    }
                }
                
                ctx.stroke();
            }
            
            // Generate the terrain
            function generateTerrain() {
                clearMap();
                
                // Step 1: Roll 1d6 to determine number of dice to place
                const numDice = rollDie();
                
                // Step 2: Generate dice positions
                const dicePositions = generateDicePositions(numDice);
                
                // Step 3: Roll values for each die
                const diceValues = dicePositions.map(() => rollDie());
                
                // Store dice data
                mapData.dice = dicePositions.map((pos, index) => ({
                    x: pos.x,
                    y: pos.y,
                    value: diceValues[index]
                }));
                
                // Step 4: Draw region boundaries
                drawRegionBoundaries(dicePositions);
                
                // Step 5: Draw dice on top
                dicePositions.forEach((pos, i) => {
                    drawDie(pos.x, pos.y, diceValues[i]);
                });
            }
            
            // Initialize
            clearMap();
            
            // Events
            generateBtn.addEventListener('click', generateTerrain);
            clearBtn.addEventListener('click', clearMap);
        });
    </script>
</body>
</html>
