<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cairn RPG Map Generator - Topography</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        h1 {
            text-align: center;
            color: #333;
        }
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        .map-container {
            position: relative;
            border: 1px solid #333;
            background-color: white;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        button {
            padding: 10px 15px;
            background-color: #4a4a4a;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #333;
        }
    </style>
</head>
<body>
    <h1>Cairn RPG Map Generator - Topography</h1>
    
    <div class="container">
        <div class="controls">
            <button id="generateBtn">Generate Terrain</button>
            <button id="clearBtn">Clear Map</button>
        </div>
        
        <div class="map-container">
            <canvas id="mapCanvas" width="800" height="600"></canvas>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('mapCanvas');
            const ctx = canvas.getContext('2d');
            const generateBtn = document.getElementById('generateBtn');
            const clearBtn = document.getElementById('clearBtn');
            
            // Map data structure
            let mapData = {
                width: canvas.width,
                height: canvas.height,
                dice: []
            };
            
            // Clear the map
            function clearMap() {
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                mapData.dice = [];
            }
            
            // Roll a die
            function rollDie() {
                return Math.floor(Math.random() * 6) + 1;
            }
            
            // Generate random dice positions on the map
            function generateDicePositions(numDice) {
                const positions = [];
                const minDistance = 120; // Minimum distance between dice
                const margin = 70;       // Margin from the edges
                
                for (let i = 0; i < numDice; i++) {
                    let x, y, tooClose;
                    let attempts = 0;
                    
                    // Try to find a position that's not too close to existing dice
                    do {
                        tooClose = false;
                        x = margin + Math.random() * (canvas.width - 2 * margin);
                        y = margin + Math.random() * (canvas.height - 2 * margin);
                        
                        for (const pos of positions) {
                            const distance = Math.sqrt(Math.pow(x - pos.x, 2) + Math.pow(y - pos.y, 2));
                            if (distance < minDistance) {
                                tooClose = true;
                                break;
                            }
                        }
                        
                        attempts++;
                        // If we can't find a good position after many attempts, reduce our constraints
                        if (attempts > 50) {
                            minDistance *= 0.9;
                            attempts = 0;
                        }
                    } while (tooClose);
                    
                    positions.push({ x, y });
                }
                
                return positions;
            }
            
            // Draw a die on the canvas
            function drawDie(x, y, value) {
                // Draw die square
                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                
                // Rotate die slightly for visual interest
                ctx.save();
                ctx.translate(x, y);
                const rotation = (Math.random() - 0.5) * 0.5;
                ctx.rotate(rotation);
                
                // Draw die
                const dieSize = 40;
                ctx.fillRect(-dieSize/2, -dieSize/2, dieSize, dieSize);
                ctx.strokeRect(-dieSize/2, -dieSize/2, dieSize, dieSize);
                
                // Draw die value
                ctx.fillStyle = 'black';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(value, 0, 0);
                
                ctx.restore();
            }
            
            // Draw dividing lines between regions
            function drawRegionDividers(dicePositions) {
                // Create a set of points to make curvy lines between regions
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                
                // Generate random control points for curves
                const controlPoints = [];
                const numControlPoints = 15;
                
                for (let i = 0; i < numControlPoints; i++) {
                    controlPoints.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height
                    });
                }
                
                // Draw curved lines separating regions
                ctx.beginPath();
                
                // Create lines connecting regions
                for (let i = 0; i < dicePositions.length; i++) {
                    for (let j = i + 1; j < dicePositions.length; j++) {
                        const p1 = dicePositions[i];
                        const p2 = dicePositions[j];
                        
                        // Find midpoint between dice
                        const midX = (p1.x + p2.x) / 2;
                        const midY = (p1.y + p2.y) / 2;
                        
                        // Find a perpendicular line and extend it
                        const dx = p2.x - p1.x;
                        const dy = p2.y - p1.y;
                        
                        // Perpendicular vector
                        const perpX = -dy;
                        const perpY = dx;
                        
                        // Normalize and scale
                        const length = Math.sqrt(perpX * perpX + perpY * perpY);
                        const normPerpX = perpX / length;
                        const normPerpY = perpY / length;
                        
                        // Find random control points along this perpendicular
                        const scale = 300 + Math.random() * 200;
                        
                        // Start point
                        const startX = midX + normPerpX * scale;
                        const startY = midY + normPerpY * scale;
                        
                        // End point
                        const endX = midX - normPerpX * scale;
                        const endY = midY - normPerpY * scale;
                        
                        // Draw curve
                        ctx.moveTo(startX, startY);
                        
                        // Find closest control points
                        let cp1 = null, cp2 = null;
                        let minDist1 = Infinity, minDist2 = Infinity;
                        
                        for (const cp of controlPoints) {
                            const distToStart = Math.sqrt(Math.pow(cp.x - startX, 2) + Math.pow(cp.y - startY, 2));
                            const distToEnd = Math.sqrt(Math.pow(cp.x - endX, 2) + Math.pow(cp.y - endY, 2));
                            
                            if (distToStart < minDist1) {
                                minDist1 = distToStart;
                                cp1 = cp;
                            }
                            
                            if (distToEnd < minDist2) {
                                minDist2 = distToEnd;
                                cp2 = cp;
                            }
                        }
                        
                        // Draw bezier curve with control points
                        if (cp1 && cp2) {
                            ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, endX, endY);
                        } else {
                            ctx.lineTo(endX, endY);
                        }
                    }
                }
                
                // Add some extra dividing lines extending to the edges
                for (let i = 0; i < 5; i++) {
                    const p = controlPoints[i % controlPoints.length];
                    
                    // Random angle
                    const angle = Math.random() * Math.PI * 2;
                    const length = Math.max(canvas.width, canvas.height);
                    
                    const endX = p.x + Math.cos(angle) * length;
                    const endY = p.y + Math.sin(angle) * length;
                    
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(endX, endY);
                }
                
                ctx.stroke();
            }
            
            // Generate the terrain
            function generateTerrain() {
                clearMap();
                
                // Step 1: Roll 1d6 to determine number of dice to place
                const numDice = rollDie();
                
                // Step 2: Generate dice positions
                const dicePositions = generateDicePositions(numDice);
                
                // Step 3: Roll values for each die
                const diceValues = dicePositions.map(() => rollDie());
                
                // Store dice data
                mapData.dice = dicePositions.map((pos, index) => ({
                    x: pos.x,
                    y: pos.y,
                    value: diceValues[index]
                }));
                
                // Step 4: Draw dividing lines between regions
                drawRegionDividers(dicePositions);
                
                // Step 5: Draw dice on top
                dicePositions.forEach((pos, i) => {
                    drawDie(pos.x, pos.y, diceValues[i]);
                });
            }
            
            // Initialize
            clearMap();
            
            // Events
            generateBtn.addEventListener('click', generateTerrain);
            clearBtn.addEventListener('click', clearMap);
        });
    </script>
</body>
</html>
