<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cairn RPG Map Generator - Topography</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        h1 {
            text-align: center;
            color: #333;
        }
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        .map-container {
            position: relative;
            border: 1px solid #333;
            background-color: white;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        button {
            padding: 10px 15px;
            background-color: #4a4a4a;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #333;
        }
    </style>
</head>
<body>
    <h1>Cairn RPG Map Generator - Topography</h1>
    
    <div class="container">
        <div class="controls">
            <button id="generateBtn">Generate Terrain</button>
            <button id="clearBtn">Clear Map</button>
        </div>
        
        <div class="map-container">
            <canvas id="mapCanvas" width="800" height="600"></canvas>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('mapCanvas');
            const ctx = canvas.getContext('2d');
            const generateBtn = document.getElementById('generateBtn');
            const clearBtn = document.getElementById('clearBtn');
            
            // Map data structure
            let mapData = {
                width: canvas.width,
                height: canvas.height,
                dice: []
            };
            
            // Clear the map
            function clearMap() {
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                mapData.dice = [];
            }
            
            // Roll a die
            function rollDie() {
                return Math.floor(Math.random() * 6) + 1;
            }
            
            // Generate random dice positions on the map
            function generateDicePositions(numDice) {
                const positions = [];
                const minDistance = 120; // Minimum distance between dice
                const margin = 80;       // Margin from the edges
                
                for (let i = 0; i < numDice; i++) {
                    let x, y, tooClose;
                    let attempts = 0;
                    
                    // Try to find a position that's not too close to existing dice
                    do {
                        tooClose = false;
                        x = margin + Math.random() * (canvas.width - 2 * margin);
                        y = margin + Math.random() * (canvas.height - 2 * margin);
                        
                        for (const pos of positions) {
                            const distance = Math.sqrt(Math.pow(x - pos.x, 2) + Math.pow(y - pos.y, 2));
                            if (distance < minDistance) {
                                tooClose = true;
                                break;
                            }
                        }
                        
                        attempts++;
                        // If we can't find a good position after many attempts, reduce our constraints
                        if (attempts > 50) {
                            minDistance *= 0.9;
                            attempts = 0;
                        }
                    } while (tooClose);
                    
                    positions.push({ x, y });
                }
                
                return positions;
            }
            
            // Draw a die on the canvas
            function drawDie(x, y, value) {
                // Draw die square
                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                
                // Apply small random rotation for visual interest
                ctx.save();
                ctx.translate(x, y);
                const rotation = (Math.random() - 0.5) * 0.2;
                ctx.rotate(rotation);
                
                // Draw die
                const dieSize = 40;
                ctx.fillRect(-dieSize/2, -dieSize/2, dieSize, dieSize);
                ctx.strokeRect(-dieSize/2, -dieSize/2, dieSize, dieSize);
                
                // Draw die value
                ctx.fillStyle = 'black';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(value, 0, 0);
                
                ctx.restore();
            }
            
            // Generate curved boundaries between regions
            function drawRegionBoundaries(dicePositions) {
                // Create a simplified version of a Voronoi diagram
                const resolution = 4; // Check every 4 pixels
                const noiseLevel = 20; // Random noise to add to boundaries for organic feel
                
                // First, determine region ownership for each cell
                // For simplicity, we'll just use a grid approach
                const boundaries = new Set();
                
                // Identify boundary points
                for (let x = 0; x < canvas.width; x += resolution) {
                    for (let y = 0; y < canvas.height; y += resolution) {
                        // Find the two closest dice to this point
                        let closest = -1;
                        let secondClosest = -1;
                        let minDist = Infinity;
                        let secondMinDist = Infinity;
                        
                        for (let i = 0; i < dicePositions.length; i++) {
                            const pos = dicePositions[i];
                            const dist = Math.sqrt(Math.pow(x - pos.x, 2) + Math.pow(y - pos.y, 2));
                            
                            if (dist < minDist) {
                                secondMinDist = minDist;
                                secondClosest = closest;
                                minDist = dist;
                                closest = i;
                            } else if (dist < secondMinDist) {
                                secondMinDist = dist;
                                secondClosest = i;
                            }
                        }
                        
                        // If we're almost equidistant to two dice, we're on a boundary
                        if (closest !== -1 && secondClosest !== -1) {
                            const diff = secondMinDist - minDist;
                            if (diff < 10) {
                                // Add some noise to make the boundary more natural
                                const noisedX = x + (Math.random() - 0.5) * noiseLevel;
                                const noisedY = y + (Math.random() - 0.5) * noiseLevel;
                                
                                // Add to boundaries
                                boundaries.add(`${Math.round(noisedX)},${Math.round(noisedY)}`);
                            }
                        }
                    }
                }
                
                // Draw the boundaries
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 1;
                
                for (const point of boundaries) {
                    const [x, y] = point.split(',').map(Number);
                    
                    // Small dots that together form lines
                    ctx.beginPath();
                    ctx.arc(x, y, 0.5, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Connect boundaries to the edge of the map
                const edgePoints = [];
                const numEdgePoints = 12; // Number of points to extend from edges
                
                // Add random edge connection points
                for (let i = 0; i < numEdgePoints; i++) {
                    // Pick a random side
                    const side = Math.floor(Math.random() * 4);
                    let x, y;
                    
                    switch (side) {
                        case 0: // Top
                            x = Math.random() * canvas.width;
                            y = 0;
                            break;
                        case 1: // Right
                            x = canvas.width;
                            y = Math.random() * canvas.height;
                            break;
                        case 2: // Bottom
                            x = Math.random() * canvas.width;
                            y = canvas.height;
                            break;
                        case 3: // Left
                            x = 0;
                            y = Math.random() * canvas.height;
                            break;
                    }
                    
                    edgePoints.push({ x, y });
                }
                
                // Find the closest dice to each edge point
                ctx.lineWidth = 2;
                for (const edge of edgePoints) {
                    let closestDie = null;
                    let minDist = Infinity;
                    
                    for (const pos of dicePositions) {
                        const dist = Math.sqrt(Math.pow(edge.x - pos.x, 2) + Math.pow(edge.y - pos.y, 2));
                        if (dist < minDist) {
                            minDist = dist;
                            closestDie = pos;
                        }
                    }
                    
                    if (closestDie) {
                        // Draw a curved path from edge to the die
                        ctx.beginPath();
                        ctx.moveTo(edge.x, edge.y);
                        
                        // Control points for the curve
                        const midX = (edge.x + closestDie.x) / 2;
                        const midY = (edge.y + closestDie.y) / 2;
                        
                        // Add some randomness to control points
                        const ctrlX = midX + (Math.random() - 0.5) * 100;
                        const ctrlY = midY + (Math.random() - 0.5) * 100;
                        
                        // Draw a quadratic curve
                        ctx.quadraticCurveTo(ctrlX, ctrlY, closestDie.x, closestDie.y);
                        ctx.stroke();
                    }
                }
            }
            
            // Generate the terrain
            function generateTerrain() {
                clearMap();
                
                // Step 1: Roll 1d6 to determine number of dice to place
                const numDice = rollDie();
                
                // Step 2: Generate dice positions
                const dicePositions = generateDicePositions(numDice);
                
                // Step 3: Roll values for each die
                const diceValues = dicePositions.map(() => rollDie());
                
                // Store dice data
                mapData.dice = dicePositions.map((pos, index) => ({
                    x: pos.x,
                    y: pos.y,
                    value: diceValues[index]
                }));
                
                // Step 4: Draw region boundaries
                drawRegionBoundaries(dicePositions);
                
                // Step 5: Draw dice on top
                dicePositions.forEach((pos, i) => {
                    drawDie(pos.x, pos.y, diceValues[i]);
                });
            }
            
            // Initialize
            clearMap();
            
            // Events
            generateBtn.addEventListener('click', generateTerrain);
            clearBtn.addEventListener('click', clearMap);
        });
    </script>
</body>
</html>
