<!--
======================================================================================
CAIRN RPG MAP GENERATOR - TOPOGRAPHY MODULE
======================================================================================

This module implements Step 1 of the Cairn RPG map generation process: Terrain Generation.

HOW IT WORKS:
1. Roll 1d6 to determine how many dice to place on the map
2. Place these dice at random positions with sufficient spacing
3. Roll values for each die (1-6)
4. Generate region boundaries between dice using a modified Voronoi diagram approach:
   - Assign each pixel to its closest die region
   - Find boundary pixels where regions meet
   - Connect boundary pixels into continuous paths
   - Simplify and draw as dark grey lines
5. Display the dice on top of the map

TECHNICAL APPROACH:
- Uses HTML5 Canvas for drawing
- Implements dice placement with minimum distance requirements
- Uses a pixel-based approach to identify region boundaries
- Connects boundary pixels into paths using a nearest-neighbor algorithm
- Renders clean, single lines between regions

This represents the foundation of the map generation process. In future steps (not implemented 
here), these regions would be assigned terrain types based on the dice values:
- 1-3: Easy terrain (plains, grasslands, etc.)
- 4-5: Tough terrain (forests, hills, etc.)
- 6: Perilous terrain (mountains, swamps, etc.)

Each region would also receive a landmark, and the map would be further developed with
rivers, points of interest, and paths between locations.
======================================================================================
-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cairn RPG Map Generator - Topography</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        h1 {
            text-align: center;
            color: #333;
        }
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        .map-container {
            position: relative;
            border: 1px solid #333;
            background-color: white;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        button {
            padding: 10px 15px;
            background-color: #4a4a4a;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #333;
        }
    </style>
</head>
<body>
    <h1>Cairn RPG Map Generator - Topography</h1>
    
    <div class="container">
        <div class="controls">
            <button id="generateBtn">Generate Terrain</button>
            <button id="clearBtn">Clear Map</button>
        </div>
        
        <div class="map-container">
            <canvas id="mapCanvas" width="800" height="600"></canvas>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('mapCanvas');
            const ctx = canvas.getContext('2d');
            const generateBtn = document.getElementById('generateBtn');
            const clearBtn = document.getElementById('clearBtn');
            
            // Map data structure
            let mapData = {
                width: canvas.width,
                height: canvas.height,
                dice: []
            };
            
            // Terrain and landmark tables
            const terrainTables = {
                easy: [
                    "Bluffs", "Dells", "Farmlands", "Fells", "Foothills", 
                    "Glens", "Grasslands", "Gulleys", "Heaths", "Lowlands", 
                    "Meadows", "Moors", "Pampas", "Pastures", "Plains", 
                    "Plateaus", "Prairies", "Savannas", "Steppes", "Valleys"
                ],
                tough: [
                    "Barrens", "Canyons", "Chaparral", "Coral Reefs", "Deserts", 
                    "Dunes", "Estuaries", "Fens", "Forests", "Heathlands", 
                    "Hills", "Mangroves", "Marshlands", "Moorlands", "Rainforests", 
                    "Scrublands", "Taiga", "Thickets", "Tundra", "Woodlands"
                ],
                perilous: [
                    "Alpine Meadows", "Bogs", "Boulders", "Caverns", "Cliffs", 
                    "Craters", "Crevasses", "Geysers", "Glaciers", "Gorges", 
                    "Hollows", "Ice Fields", "Jungles", "Lava Fields", "Mountains", 
                    "Peatlands", "Quagmires", "Ravine", "Swamps", "Wastelands"
                ]
            };
            
            const landmarkTables = {
                easy: [
                    "Broken Sundial", "Circle of Menhirs", "Circular Maze", "Cloud Stairway", "Dead Aqueduct", 
                    "Enormous Footprint", "Fallen Column", "False Oasis", "Giant's Throne", "Glittering Cascade", 
                    "Golden Bridge", "Great Stone Face", "Great Waterwheel", "Heart Tree", "Opaque Lake", 
                    "Petrified Forest", "Pit of Cold Fire", "Silver Face", "Sinkhole", "Titanic Gate"
                ],
                tough: [
                    "Algae Falls", "Basalt Columns", "Behemoth Graveyard", "Canyon Bridge", "Cinder Cones", 
                    "Half-Buried Ark", "Flame Pits", "Forest of Arrows", "Frozen Waterfall", "Fungal Forest", 
                    "Hanging Valley", "Inverted Lighthouse", "Leviathan Bones", "Massive Crater", "Massive Dung Ball", 
                    "Salt Flat Mirrors", "Shrouded Ziggurat", "Stalagmite Forest", "Sunken Colossus", "Titan's Table"
                ],
                perilous: [
                    "Active Volcano", "Ammonia Caves", "Bone Mountain", "Crystalline Forest", "Dome of Darkness", 
                    "Enormous Hive", "Floating Object", "Inactive Automaton", "Land Scar", "Large Vents", 
                    "Magma Sculptures", "Man on the Mountain", "Meteor Garden", "Obsidian Needle", "Reverse Waterfall", 
                    "River of Sulfur", "Siren Stones", "Sky-Root", "Titanic Ribcage", "Weeping Bubble"
                ]
            };
            
            // Clear the map
            function clearMap() {
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                mapData.dice = [];
                
                // Reset buttons
                document.getElementById('generateBtn').style.display = 'inline-block';
                const rollTablesBtn = document.getElementById('rollTablesBtn');
                if (rollTablesBtn) {
                    rollTablesBtn.style.display = 'none';
                }
            }
            
            // Roll a die (d6)
            function rollDie() {
                return Math.floor(Math.random() * 6) + 1;
            }
            
            // Roll d20
            function rollD20() {
                return Math.floor(Math.random() * 20);  // 0-19 for array index
            }
            
            // Get terrain type based on die value
            function getTerrainType(dieValue) {
                if (dieValue <= 3) return "easy";
                if (dieValue <= 5) return "tough";
                return "perilous";
            }
            
            // Generate random dice positions on the map
            function generateDicePositions(numDice) {
                const positions = [];
                const minDistance = 120; // Minimum distance between dice
                const margin = 80;       // Margin from the edges
                
                for (let i = 0; i < numDice; i++) {
                    let x, y, tooClose;
                    let attempts = 0;
                    
                    // Try to find a position that's not too close to existing dice
                    do {
                        tooClose = false;
                        x = margin + Math.random() * (canvas.width - 2 * margin);
                        y = margin + Math.random() * (canvas.height - 2 * margin);
                        
                        for (const pos of positions) {
                            const distance = Math.sqrt(Math.pow(x - pos.x, 2) + Math.pow(y - pos.y, 2));
                            if (distance < minDistance) {
                                tooClose = true;
                                break;
                            }
                        }
                        
                        attempts++;
                        // If we can't find a good position after many attempts, reduce our constraints
                        if (attempts > 50) {
                            minDistance *= 0.9;
                            attempts = 0;
                        }
                    } while (tooClose);
                    
                    positions.push({ x, y });
                }
                
                return positions;
            }
            
            // Draw a die on the canvas
            function drawDie(x, y, value) {
                // Draw die square
                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                
                // Apply small random rotation for visual interest
                ctx.save();
                ctx.translate(x, y);
                const rotation = (Math.random() - 0.5) * 0.2;
                ctx.rotate(rotation);
                
                // Draw die
                const dieSize = 40;
                ctx.fillRect(-dieSize/2, -dieSize/2, dieSize, dieSize);
                ctx.strokeRect(-dieSize/2, -dieSize/2, dieSize, dieSize);
                
                // Draw die value
                ctx.fillStyle = 'black';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(value, 0, 0);
                
                ctx.restore();
            }
            
            // Generate boundaries using Voronoi principles
            function drawRegionBoundaries(dicePositions) {
                // For cleaner lines, let's use an approach that creates proper region boundaries
                // based on Voronoi diagram principles
                
                // Store region information
                const regions = [];
                
                // Assign each pixel to the closest dice center to identify regions
                const pixelData = new Array(canvas.width * canvas.height).fill(-1);
                
                // Calculate region centroids
                const regionCentroids = new Array(dicePositions.length).fill().map(() => ({
                    sumX: 0,
                    sumY: 0,
                    count: 0
                }));
                
                for (let x = 0; x < canvas.width; x++) {
                    for (let y = 0; y < canvas.height; y++) {
                        let minDist = Infinity;
                        let closestRegion = -1;
                        
                        for (let i = 0; i < dicePositions.length; i++) {
                            const pos = dicePositions[i];
                            const dist = Math.sqrt(Math.pow(x - pos.x, 2) + Math.pow(y - pos.y, 2));
                            
                            if (dist < minDist) {
                                minDist = dist;
                                closestRegion = i;
                            }
                        }
                        
                        const pixelIndex = y * canvas.width + x;
                        pixelData[pixelIndex] = closestRegion;
                        
                        // Add this pixel to the centroid calculation
                        if (closestRegion !== -1) {
                            regionCentroids[closestRegion].sumX += x;
                            regionCentroids[closestRegion].sumY += y;
                            regionCentroids[closestRegion].count++;
                        }
                    }
                }
                
                // Calculate the actual centroid of each region
                const centroids = regionCentroids.map((data, index) => {
                    if (data.count > 0) {
                        return {
                            x: Math.round(data.sumX / data.count),
                            y: Math.round(data.sumY / data.count),
                            regionIndex: index
                        };
                    } else {
                        // Fallback to dice position if no pixels
                        return {
                            x: dicePositions[index].x,
                            y: dicePositions[index].y,
                            regionIndex: index
                        };
                    }
                });
                
                // Store centroids for later use with text placement
                mapData.regionCentroids = centroids;
                
                // Find boundary pixels where adjacent pixels belong to different regions
                const boundaryPixels = new Set();
                
                for (let x = 1; x < canvas.width - 1; x++) {
                    for (let y = 1; y < canvas.height - 1; y++) {
                        const currentRegion = pixelData[y * canvas.width + x];
                        
                        // Check neighboring pixels (4-connected neighbors)
                        const neighbors = [
                            pixelData[y * canvas.width + (x - 1)],      // left
                            pixelData[y * canvas.width + (x + 1)],      // right
                            pixelData[(y - 1) * canvas.width + x],      // top
                            pixelData[(y + 1) * canvas.width + x]       // bottom
                        ];
                        
                        // If any neighbor belongs to a different region, this is a boundary
                        for (const neighbor of neighbors) {
                            if (neighbor !== currentRegion && currentRegion !== -1 && neighbor !== -1) {
                                boundaryPixels.add(`${x},${y}`);
                                break;
                            }
                        }
                    }
                }
                
                // Convert boundary pixels to connected paths
                const boundaryList = [...boundaryPixels].map(coord => {
                    const [x, y] = coord.split(',').map(Number);
                    return { x, y };
                });
                
                // Simple clustering to group nearby boundary pixels
                const pathSegments = [];
                const visited = new Set();
                
                // Function to find neighboring boundary pixels
                function getNeighbors(point, radius = 2) {
                    const neighbors = [];
                    
                    for (let i = 0; i < boundaryList.length; i++) {
                        if (visited.has(i)) continue;
                        
                        const other = boundaryList[i];
                        const dist = Math.sqrt(Math.pow(point.x - other.x, 2) + Math.pow(point.y - other.y, 2));
                        
                        if (dist <= radius) {
                            neighbors.push({ index: i, point: other, distance: dist });
                        }
                    }
                    
                    // Sort by distance
                    return neighbors.sort((a, b) => a.distance - b.distance);
                }
                
                // Build path segments by following adjacent boundary pixels
                for (let i = 0; i < boundaryList.length; i++) {
                    if (visited.has(i)) continue;
                    
                    const segment = [boundaryList[i]];
                    visited.add(i);
                    
                    // Trace path in both directions
                    let current = boundaryList[i];
                    let keepGoing = true;
                    
                    while (keepGoing) {
                        const neighbors = getNeighbors(current);
                        if (neighbors.length > 0) {
                            const next = neighbors[0];
                            segment.push(next.point);
                            visited.add(next.index);
                            current = next.point;
                        } else {
                            keepGoing = false;
                        }
                        
                        // Prevent endless loops
                        if (segment.length > 1000) {
                            keepGoing = false;
                        }
                    }
                    
                    if (segment.length > 5) {
                        pathSegments.push(segment);
                    }
                }
                
                // Simplify paths (reduce number of points)
                const simplifiedSegments = pathSegments.map(segment => {
                    // Only keep every Nth point for smoother lines
                    const simplified = [];
                    for (let i = 0; i < segment.length; i += 3) {
                        simplified.push(segment[i]);
                    }
                    return simplified;
                });
                
                // Draw the boundaries as single, solid dark grey lines
                ctx.strokeStyle = '#444'; // Dark grey
                ctx.lineWidth = 1.2;
                ctx.lineJoin = 'round';
                ctx.lineCap = 'round';
                
                for (const segment of simplifiedSegments) {
                    if (segment.length < 2) continue;
                    
                    ctx.beginPath();
                    ctx.moveTo(segment[0].x, segment[0].y);
                    
                    // Use curve interpolation for smooth boundaries
                    for (let i = 1; i < segment.length; i++) {
                        ctx.lineTo(segment[i].x, segment[i].y);
                    }
                    
                    ctx.stroke();
                }
                
                // For debugging: visualize the centroids
                // ctx.fillStyle = 'red';
                // centroids.forEach(centroid => {
                //     ctx.beginPath();
                //     ctx.arc(centroid.x, centroid.y, 5, 0, Math.PI * 2);
                //     ctx.fill();
                // });
            }
            
            // Roll on terrain type tables
            function rollOnTerrainTables() {
                // Clear the canvas except for region boundaries
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Redraw region boundaries
                drawRegionBoundaries(mapData.dice.map(die => ({ x: die.x, y: die.y })));
                
                // Track placed labels to avoid overlap
                const placedLabels = [];
                
                // Helper function to check if a new label would overlap existing ones
                function wouldOverlap(x, y, width, height) {
                    for (const label of placedLabels) {
                        // Simple rectangular collision detection
                        if (x < label.x + label.width &&
                            x + width > label.x &&
                            y < label.y + label.height &&
                            y + height > label.y) {
                            return true;
                        }
                    }
                    return false;
                }
                
                // Helper function to find best position for a label using region centroid
                function findBestPosition(dieIndex, textWidth, textHeight) {
                    // Check if we have a calculated centroid for this region
                    if (mapData.regionCentroids && mapData.regionCentroids[dieIndex]) {
                        const centroid = mapData.regionCentroids[dieIndex];
                        
                        // Position the text centered at the centroid
                        const x = centroid.x - textWidth / 2;
                        const y = centroid.y - textHeight / 2;
                        
                        // Ensure position is within canvas bounds
                        const adjustedX = Math.max(10, Math.min(canvas.width - textWidth - 10, x));
                        const adjustedY = Math.max(textHeight - 10, Math.min(canvas.height - textHeight - 10, y));
                        
                        // If not overlapping with other labels, use this centroid position
                        if (!wouldOverlap(adjustedX, adjustedY, textWidth, textHeight)) {
                            return { x: adjustedX, y: adjustedY };
                        }
                        
                        // Try positions around the centroid
                        const offsets = [
                            { x: 0, y: -textHeight - 10 },  // Above
                            { x: 0, y: textHeight + 10 },   // Below
                            { x: -textWidth - 10, y: 0 },   // Left
                            { x: textWidth + 10, y: 0 },    // Right
                            { x: -textWidth - 10, y: -textHeight - 10 }, // Top-left
                            { x: textWidth + 10, y: -textHeight - 10 },  // Top-right
                            { x: -textWidth - 10, y: textHeight + 10 },  // Bottom-left
                            { x: textWidth + 10, y: textHeight + 10 }    // Bottom-right
                        ];
                        
                        for (const offset of offsets) {
                            const posX = centroid.x + offset.x;
                            const posY = centroid.y + offset.y;
                            
                            // Ensure position is within canvas bounds
                            if (posX >= 10 && posX + textWidth <= canvas.width - 10 &&
                                posY >= textHeight - 10 && posY + textHeight <= canvas.height - 10) {
                                    
                                if (!wouldOverlap(posX, posY, textWidth, textHeight)) {
                                    return { x: posX, y: posY };
                                }
                            }
                        }
                    }
                    
                    // Fallback to using the die position
                    const die = mapData.dice[dieIndex];
                    
                    // Try different offsets from the die position
                    const possiblePositions = [
                        { x: die.x - textWidth/2, y: die.y - textHeight - 10 },  // Above
                        { x: die.x - textWidth/2, y: die.y + 10 },               // Below
                        { x: die.x - textWidth - 10, y: die.y - textHeight/2 },  // Left
                        { x: die.x + 10, y: die.y - textHeight/2 },              // Right
                        { x: die.x - textWidth - 10, y: die.y - textHeight - 10 }, // Top-left
                        { x: die.x + 10, y: die.y - textHeight - 10 },            // Top-right
                        { x: die.x - textWidth - 10, y: die.y + 10 },             // Bottom-left
                        { x: die.x + 10, y: die.y + 10 }                          // Bottom-right
                    ];
                    
                    // Ensure position is within canvas bounds
                    const validPositions = possiblePositions.filter(pos => 
                        pos.x >= 10 && 
                        pos.x + textWidth <= canvas.width - 10 &&
                        pos.y >= textHeight - 10 && 
                        pos.y + textHeight <= canvas.height - 10
                    );
                    
                    // Find first position that doesn't overlap
                    for (const pos of validPositions) {
                        if (!wouldOverlap(pos.x, pos.y, textWidth, textHeight)) {
                            return pos;
                        }
                    }
                    
                    // If all positions overlap, return the first valid one anyway
                    return validPositions[0] || { x: die.x - textWidth/2, y: die.y - textHeight - 10 };
                }
                
                // For each die, replace with terrain and landmark info
                mapData.dice.forEach((die, dieIndex) => {
                    const terrainType = getTerrainType(die.value);
                    
                    // Separate rolls for terrain and landmark
                    const terrainRoll = rollD20();
                    const landmarkRoll = rollD20();
                    
                    // Get terrain and landmark from tables
                    const terrainResult = terrainTables[terrainType][terrainRoll];
                    const landmarkResult = landmarkTables[terrainType][landmarkRoll];
                    
                    // Prepare text
                    const typeLabel = terrainType.charAt(0).toUpperCase() + terrainType.slice(1);
                    const terrainText = `${typeLabel}: ${terrainResult}`;
                    const landmarkText = `Landmark: ${landmarkResult}`;
                    
                    // Measure text
                    ctx.font = 'bold 16px Arial';
                    const terrainWidth = ctx.measureText(terrainText).width;
                    ctx.font = '14px Arial';
                    const landmarkWidth = ctx.measureText(landmarkText).width;
                    
                    const textWidth = Math.max(terrainWidth, landmarkWidth) + 20;
                    const textHeight = 40; // Approximate height for both lines
                    
                    // Find best position for this label using region centroid
                    const position = findBestPosition(dieIndex, textWidth, textHeight);
                    
                    // Register this label to avoid future overlaps
                    placedLabels.push({
                        x: position.x,
                        y: position.y,
                        width: textWidth,
                        height: textHeight
                    });
                    
                    // Draw semi-transparent background for better readability
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.fillRect(position.x - 5, position.y - 20, textWidth + 10, textHeight + 10);
                    
                    // Draw terrain text
                    ctx.fillStyle = 'black';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText(terrainText, position.x, position.y);
                    
                    // Draw landmark text
                    ctx.font = 'bold 14px Arial';
                    ctx.fillText('Landmark:', position.x, position.y + 20);
                    ctx.font = '14px Arial';
                    ctx.fillText(landmarkResult, position.x + 80, position.y + 20);
                });
                
                // Hide the roll button after processing
                document.getElementById('rollTablesBtn').style.display = 'none';
            }
            
            // Generate the terrain
            function generateTerrain() {
                clearMap();
                
                // Step 1: Roll 1d6 to determine number of dice to place
                const numDice = rollDie();
                
                // Step 2: Generate dice positions
                const dicePositions = generateDicePositions(numDice);
                
                // Step 3: Roll values for each die
                const diceValues = dicePositions.map(() => rollDie());
                
                // Store dice data
                mapData.dice = dicePositions.map((pos, index) => ({
                    x: pos.x,
                    y: pos.y,
                    value: diceValues[index]
                }));
                
                // Step 4: Draw region boundaries
                drawRegionBoundaries(dicePositions);
                
                // Step 5: Draw dice on top
                dicePositions.forEach((pos, i) => {
                    drawDie(pos.x, pos.y, diceValues[i]);
                });
                
                // Hide generate button and show the "Next Step" button
                document.getElementById('generateBtn').style.display = 'none';
                
                // Create and add the "Roll on Terrain Tables" button if it doesn't exist
                if (!document.getElementById('rollTablesBtn')) {
                    const rollTablesBtn = document.createElement('button');
                    rollTablesBtn.id = 'rollTablesBtn';
                    rollTablesBtn.textContent = 'Next Step: Roll on Terrain Type Tables';
                    rollTablesBtn.style.backgroundColor = '#0066cc';
                    rollTablesBtn.addEventListener('click', rollOnTerrainTables);
                    document.querySelector('.controls').appendChild(rollTablesBtn);
                } else {
                    document.getElementById('rollTablesBtn').style.display = 'inline-block';
                }
            }
            
            // Initialize
            clearMap();
            
            // Events
            generateBtn.addEventListener('click', generateTerrain);
            clearBtn.addEventListener('click', clearMap);
        });
    </script>
</body>
</html>
