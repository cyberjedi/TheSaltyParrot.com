<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cairn RPG Map Generator - Topography</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        h1 {
            text-align: center;
            color: #333;
        }
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        .map-container {
            position: relative;
            border: 1px solid #333;
            background-color: white;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        button {
            padding: 10px 15px;
            background-color: #4a4a4a;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #333;
        }
    </style>
</head>
<body>
    <h1>Cairn RPG Map Generator - Topography</h1>
    
    <div class="container">
        <div class="controls">
            <button id="generateBtn">Generate Terrain</button>
            <button id="clearBtn">Clear Map</button>
        </div>
        
        <div class="map-container">
            <canvas id="mapCanvas" width="800" height="600"></canvas>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('mapCanvas');
            const ctx = canvas.getContext('2d');
            const generateBtn = document.getElementById('generateBtn');
            const clearBtn = document.getElementById('clearBtn');
            
            // Map data structure
            let mapData = {
                width: canvas.width,
                height: canvas.height,
                dice: []
            };
            
            // Clear the map
            function clearMap() {
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                mapData.dice = [];
            }
            
            // Roll a die
            function rollDie() {
                return Math.floor(Math.random() * 6) + 1;
            }
            
            // Generate random dice positions on the map
            function generateDicePositions(numDice) {
                const positions = [];
                const minDistance = 120; // Minimum distance between dice
                const margin = 80;       // Margin from the edges
                
                for (let i = 0; i < numDice; i++) {
                    let x, y, tooClose;
                    let attempts = 0;
                    
                    // Try to find a position that's not too close to existing dice
                    do {
                        tooClose = false;
                        x = margin + Math.random() * (canvas.width - 2 * margin);
                        y = margin + Math.random() * (canvas.height - 2 * margin);
                        
                        for (const pos of positions) {
                            const distance = Math.sqrt(Math.pow(x - pos.x, 2) + Math.pow(y - pos.y, 2));
                            if (distance < minDistance) {
                                tooClose = true;
                                break;
                            }
                        }
                        
                        attempts++;
                        // If we can't find a good position after many attempts, reduce our constraints
                        if (attempts > 50) {
                            minDistance *= 0.9;
                            attempts = 0;
                        }
                    } while (tooClose);
                    
                    positions.push({ x, y });
                }
                
                return positions;
            }
            
            // Draw a die on the canvas
            function drawDie(x, y, value) {
                // Draw die square
                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                
                // Apply small random rotation for visual interest
                ctx.save();
                ctx.translate(x, y);
                const rotation = (Math.random() - 0.5) * 0.2;
                ctx.rotate(rotation);
                
                // Draw die
                const dieSize = 40;
                ctx.fillRect(-dieSize/2, -dieSize/2, dieSize, dieSize);
                ctx.strokeRect(-dieSize/2, -dieSize/2, dieSize, dieSize);
                
                // Draw die value
                ctx.fillStyle = 'black';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(value, 0, 0);
                
                ctx.restore();
            }
            
            // Generate boundaries using Voronoi principles
            function drawRegionBoundaries(dicePositions) {
                // For cleaner lines, let's use an approach that creates proper region boundaries
                // based on Voronoi diagram principles
                
                // Store region information
                const regions = [];
                
                // Assign each pixel to the closest dice center to identify regions
                const pixelData = new Array(canvas.width * canvas.height).fill(-1);
                
                for (let x = 0; x < canvas.width; x++) {
                    for (let y = 0; y < canvas.height; y++) {
                        let minDist = Infinity;
                        let closestRegion = -1;
                        
                        for (let i = 0; i < dicePositions.length; i++) {
                            const pos = dicePositions[i];
                            const dist = Math.sqrt(Math.pow(x - pos.x, 2) + Math.pow(y - pos.y, 2));
                            
                            if (dist < minDist) {
                                minDist = dist;
                                closestRegion = i;
                            }
                        }
                        
                        const pixelIndex = y * canvas.width + x;
                        pixelData[pixelIndex] = closestRegion;
                    }
                }
                
                // Find boundary pixels where adjacent pixels belong to different regions
                const boundaryPixels = new Set();
                
                for (let x = 1; x < canvas.width - 1; x++) {
                    for (let y = 1; y < canvas.height - 1; y++) {
                        const currentRegion = pixelData[y * canvas.width + x];
                        
                        // Check neighboring pixels (4-connected neighbors)
                        const neighbors = [
                            pixelData[y * canvas.width + (x - 1)],      // left
                            pixelData[y * canvas.width + (x + 1)],      // right
                            pixelData[(y - 1) * canvas.width + x],      // top
                            pixelData[(y + 1) * canvas.width + x]       // bottom
                        ];
                        
                        // If any neighbor belongs to a different region, this is a boundary
                        for (const neighbor of neighbors) {
                            if (neighbor !== currentRegion && currentRegion !== -1 && neighbor !== -1) {
                                boundaryPixels.add(`${x},${y}`);
                                break;
                            }
                        }
                    }
                }
                
                // Convert boundary pixels to connected paths
                const boundaryList = [...boundaryPixels].map(coord => {
                    const [x, y] = coord.split(',').map(Number);
                    return { x, y };
                });
                
                // Simple clustering to group nearby boundary pixels
                const pathSegments = [];
                const visited = new Set();
                
                // Function to find neighboring boundary pixels
                function getNeighbors(point, radius = 2) {
                    const neighbors = [];
                    
                    for (let i = 0; i < boundaryList.length; i++) {
                        if (visited.has(i)) continue;
                        
                        const other = boundaryList[i];
                        const dist = Math.sqrt(Math.pow(point.x - other.x, 2) + Math.pow(point.y - other.y, 2));
                        
                        if (dist <= radius) {
                            neighbors.push({ index: i, point: other, distance: dist });
                        }
                    }
                    
                    // Sort by distance
                    return neighbors.sort((a, b) => a.distance - b.distance);
                }
                
                // Build path segments by following adjacent boundary pixels
                for (let i = 0; i < boundaryList.length; i++) {
                    if (visited.has(i)) continue;
                    
                    const segment = [boundaryList[i]];
                    visited.add(i);
                    
                    // Trace path in both directions
                    let current = boundaryList[i];
                    let keepGoing = true;
                    
                    while (keepGoing) {
                        const neighbors = getNeighbors(current);
                        if (neighbors.length > 0) {
                            const next = neighbors[0];
                            segment.push(next.point);
                            visited.add(next.index);
                            current = next.point;
                        } else {
                            keepGoing = false;
                        }
                        
                        // Prevent endless loops
                        if (segment.length > 1000) {
                            keepGoing = false;
                        }
                    }
                    
                    if (segment.length > 5) {
                        pathSegments.push(segment);
                    }
                }
                
                // Simplify paths (reduce number of points)
                const simplifiedSegments = pathSegments.map(segment => {
                    // Only keep every Nth point for smoother lines
                    const simplified = [];
                    for (let i = 0; i < segment.length; i += 3) {
                        simplified.push(segment[i]);
                    }
                    return simplified;
                });
                
                // Draw the boundaries as single, solid dark grey lines
                ctx.strokeStyle = '#444'; // Dark grey
                ctx.lineWidth = 1.2;
                ctx.lineJoin = 'round';
                ctx.lineCap = 'round';
                
                for (const segment of simplifiedSegments) {
                    if (segment.length < 2) continue;
                    
                    ctx.beginPath();
                    ctx.moveTo(segment[0].x, segment[0].y);
                    
                    // Use curve interpolation for smooth boundaries
                    for (let i = 1; i < segment.length; i++) {
                        ctx.lineTo(segment[i].x, segment[i].y);
                    }
                    
                    ctx.stroke();
                }
            }
            
            // Generate the terrain
            function generateTerrain() {
                clearMap();
                
                // Step 1: Roll 1d6 to determine number of dice to place
                const numDice = rollDie();
                
                // Step 2: Generate dice positions
                const dicePositions = generateDicePositions(numDice);
                
                // Step 3: Roll values for each die
                const diceValues = dicePositions.map(() => rollDie());
                
                // Store dice data
                mapData.dice = dicePositions.map((pos, index) => ({
                    x: pos.x,
                    y: pos.y,
                    value: diceValues[index]
                }));
                
                // Step 4: Draw region boundaries
                drawRegionBoundaries(dicePositions);
                
                // Step 5: Draw dice on top
                dicePositions.forEach((pos, i) => {
                    drawDie(pos.x, pos.y, diceValues[i]);
                });
            }
            
            // Initialize
            clearMap();
            
            // Events
            generateBtn.addEventListener('click', generateTerrain);
            clearBtn.addEventListener('click', clearMap);
        });
    </script>
</body>
</html>
