<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cairn RPG Map Generator - Topography</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        h1 {
            text-align: center;
            color: #333;
        }
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        .map-container {
            position: relative;
            border: 1px solid #333;
            background-color: white;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        button {
            padding: 10px 15px;
            background-color: #4a4a4a;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #333;
        }
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 20px;
            justify-content: center;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            border: 1px solid #000;
        }
    </style>
</head>
<body>
    <h1>Cairn RPG Map Generator - Topography</h1>
    
    <div class="container">
        <div class="controls">
            <button id="generateBtn">Generate Terrain</button>
            <button id="clearBtn">Clear Map</button>
        </div>
        
        <div class="map-container">
            <canvas id="mapCanvas" width="800" height="600"></canvas>
        </div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background-color: #c3e6a3;"></div>
                <span>Easy Terrain (1-3)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #92c165;"></div>
                <span>Tough Terrain (4-5)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #5a7c3d;"></div>
                <span>Perilous Terrain (6)</span>
            </div>
            <div class="legend-item">
                <div style="font-size: 24px;">â–²</div>
                <span>Landmark</span>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('mapCanvas');
            const ctx = canvas.getContext('2d');
            const generateBtn = document.getElementById('generateBtn');
            const clearBtn = document.getElementById('clearBtn');
            
            // Map data structure
            let mapData = {
                width: canvas.width,
                height: canvas.height,
                terrain: [],
                landmarks: []
            };
            
            // Terrain colors
            const terrainColors = {
                easy: '#c3e6a3',    // Light green
                tough: '#92c165',   // Medium green
                perilous: '#5a7c3d' // Dark green
            };
            
            // Clear the map
            function clearMap() {
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                mapData.terrain = [];
                mapData.landmarks = [];
            }
            
            // Roll a die
            function rollDie() {
                return Math.floor(Math.random() * 6) + 1;
            }
            
            // Get terrain type based on die roll
            function getTerrainType(dieValue) {
                if (dieValue <= 3) return 'easy';
                if (dieValue <= 5) return 'tough';
                return 'perilous';
            }
            
            // Generate random dice positions on the map
            function generateDicePositions(numDice) {
                const positions = [];
                const minDistance = 100; // Minimum distance between dice
                
                for (let i = 0; i < numDice; i++) {
                    let x, y, tooClose;
                    
                    // Try to find a position that's not too close to existing dice
                    do {
                        tooClose = false;
                        x = 50 + Math.random() * (canvas.width - 100);
                        y = 50 + Math.random() * (canvas.height - 100);
                        
                        for (const pos of positions) {
                            const distance = Math.sqrt(Math.pow(x - pos.x, 2) + Math.pow(y - pos.y, 2));
                            if (distance < minDistance) {
                                tooClose = true;
                                break;
                            }
                        }
                    } while (tooClose);
                    
                    positions.push({ x, y });
                }
                
                return positions;
            }
            
            // Draw a die on the canvas
            function drawDie(x, y, value) {
                // Draw die square
                ctx.fillStyle = '#d0d0d0';
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                
                // Rotate die slightly for visual interest
                ctx.save();
                ctx.translate(x, y);
                const rotation = (Math.random() - 0.5) * 0.5;
                ctx.rotate(rotation);
                
                // Draw die
                ctx.fillRect(-20, -20, 40, 40);
                ctx.strokeRect(-20, -20, 40, 40);
                
                // Draw die value
                ctx.fillStyle = '#333';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(value, 0, 0);
                
                ctx.restore();
            }
            
            // Generate terrain boundaries using Voronoi-like approach
            function generateTerrainBoundaries(dicePositions, diceValues) {
                // Store terrain regions
                const regions = dicePositions.map((pos, index) => ({
                    x: pos.x,
                    y: pos.y,
                    type: getTerrainType(diceValues[index]),
                    value: diceValues[index]
                }));
                
                // Draw terrain colors using pixel-by-pixel approach
                const pixelData = new Array(canvas.width * canvas.height);
                
                // First determine which region each pixel belongs to
                for (let x = 0; x < canvas.width; x++) {
                    for (let y = 0; y < canvas.height; y++) {
                        // Find closest dice center
                        let minDist = Infinity;
                        let closestRegionIndex = -1;
                        
                        for (let i = 0; i < regions.length; i++) {
                            const region = regions[i];
                            const dist = Math.sqrt(Math.pow(x - region.x, 2) + Math.pow(y - region.y, 2));
                            if (dist < minDist) {
                                minDist = dist;
                                closestRegionIndex = i;
                            }
                        }
                        
                        // Store region index for this pixel
                        const pixelIndex = y * canvas.width + x;
                        pixelData[pixelIndex] = closestRegionIndex;
                        
                        // Color based on terrain type
                        if (closestRegionIndex !== -1) {
                            const region = regions[closestRegionIndex];
                            ctx.fillStyle = terrainColors[region.type];
                            ctx.fillRect(x, y, 1, 1);
                        }
                    }
                }
                
                // Draw boundaries between ALL regions, regardless of terrain type
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                // Check for boundary pixels
                for (let x = 1; x < canvas.width - 1; x++) {
                    for (let y = 1; y < canvas.height - 1; y++) {
                        const pixelIndex = y * canvas.width + x;
                        const currentRegionIndex = pixelData[pixelIndex];
                        
                        // Check surrounding pixels
                        const leftPixel = pixelData[y * canvas.width + (x - 1)];
                        const rightPixel = pixelData[y * canvas.width + (x + 1)];
                        const topPixel = pixelData[(y - 1) * canvas.width + x];
                        const bottomPixel = pixelData[(y + 1) * canvas.width + x];
                        
                        // If any surrounding pixel belongs to a different region, this is a boundary
                        // We compare region indices, not terrain types
                        if (currentRegionIndex !== -1 && 
                            (leftPixel !== currentRegionIndex || 
                             rightPixel !== currentRegionIndex || 
                             topPixel !== currentRegionIndex || 
                             bottomPixel !== currentRegionIndex)) {
                            
                            // Draw only some pixels to avoid overly thick lines
                            if ((x + y) % 2 === 0) {
                                ctx.moveTo(x, y);
                                ctx.lineTo(x, y);
                            }
                        }
                    }
                }
                
                ctx.stroke();
                return regions;
            }
               
            
            // Generate landmarks for each terrain region
            function addLandmarks(regions) {
                // Clear dice and add landmark symbols (triangles)
                for (const region of regions) {
                    // Mock landmark name based on terrain type
                    let landmarkName = '';
                    if (region.type === 'easy') {
                        landmarkName = 'Grasslands';
                    } else if (region.type === 'tough') {
                        landmarkName = 'Marshlands';
                    } else {
                        landmarkName = 'Mountains';
                    }
                    
                    // Add landmark to data
                    mapData.landmarks.push({
                        x: region.x,
                        y: region.y,
                        name: landmarkName,
                        terrainType: region.type
                    });
                    
                    // Draw landmark triangle
                    ctx.fillStyle = 'white';
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    
                    ctx.beginPath();
                    ctx.moveTo(region.x, region.y - 15);
                    ctx.lineTo(region.x - 15, region.y + 15);
                    ctx.lineTo(region.x + 15, region.y + 15);
                    ctx.closePath();
                    
                    ctx.fill();
                    ctx.stroke();
                }
            }
            
            // Generate the complete terrain
            function generateTerrain() {
                clearMap();
                
                // Step 1: Roll 1d6 to determine number of dice to place
                const numDice = rollDie();
                
                // Step 2: Generate dice positions
                const dicePositions = generateDicePositions(numDice);
                
                // Step 3: Roll values for each die
                const diceValues = dicePositions.map(() => rollDie());
                
                // Step 4: Draw dice
                dicePositions.forEach((pos, i) => {
                    drawDie(pos.x, pos.y, diceValues[i]);
                });
                
                // Step 5: Generate terrain boundaries
                const regions = generateTerrainBoundaries(dicePositions, diceValues);
                
                // Store terrain information
                mapData.terrain = regions;
                
                // Step 6: Add landmarks
                setTimeout(() => {
                    addLandmarks(regions);
                    
                    // Label the regions with terrain type
                    regions.forEach(region => {
                        ctx.fillStyle = '#333';
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        
                        // Calculate position below the landmark
                        const textY = region.y + 40;
                        
                        let terrainName = '';
                        if (region.type === 'easy') {
                            const options = ['Plains', 'Grasslands', 'Meadows', 'Valleys'];
                            terrainName = options[Math.floor(Math.random() * options.length)];
                        } else if (region.type === 'tough') {
                            const options = ['Forests', 'Marshlands', 'Hills', 'Deserts'];
                            terrainName = options[Math.floor(Math.random() * options.length)];
                        } else {
                            const options = ['Mountains', 'Crags', 'Peaks', 'Wastelands'];
                            terrainName = options[Math.floor(Math.random() * options.length)];
                        }
                        
                        ctx.fillText(terrainName, region.x, textY);
                    });
                }, 500);
            }
            
            // Initialize
            clearMap();
            
            // Events
            generateBtn.addEventListener('click', generateTerrain);
            clearBtn.addEventListener('click', clearMap);
        });
    </script>
</body>
</html>
